module.exports = [['\n',
    '#  If you can use the *adjacency matrix*',
    '\n',
    '#  (https://en.wikipedia.org/wiki/Adjacency_matrix) in graph algorithms',
    '\n',
    '#  because it is faster, like in',
    '\n',
    '#  https://gist.github.com/shintoishere/f0fa40fe1134b20e7729',
    '\n',
    '#  ',
    '\n',
    '#  [ralf htp] [so/q/61042399] [cc by-sa 3.0]',
    '\n\n$\n'],
['\n',
    '#  Dijkstra’s algorithm same to prim’s algorithm for minimum spanning',
    '\n',
    '#  tree. Like Prim’s MST, we generate a shortest path tree with given',
    '\n',
    '#  source as root. We maintain two sets, one set contains vertices',
    '\n',
    '#  included in shortest path tree, other set includes vertices not yet',
    '\n',
    '#  included in shortest path tree. At every step of the algorithm, we',
    '\n',
    '#  find a vertex which is in the other set (set of not yet included) and',
    '\n',
    '#  has a minimum distance from the source.',
    '\n\n',
    ' import sys',
    '\n\n',
    ' class Graph():',
    '\n\n',
    '     def __init__(self, vertices):',
    '\n',
    '         self.V = vertices',
    '\n',
    '         self.graph = [[0 for column in range(vertices)]',
    '\n',
    '                   for row in range(vertices)]',
    '\n\n',
    '     def printSolution(self, dist):',
    '\n',
    '         print("Vertex tDistance from Source")',
    '\n',
    '         for node in range(self.V):',
    '\n',
    '             print(node, "t", dist[node])',
    '\n\n',
    '     def minDistance(self, dist, sptSet):',
    '\n\n',
    '         min = sys.maxint',
    '\n\n',
    '         for v in range(self.V):',
    '\n',
    '             if dist[v] < min and sptSet[v] == False:',
    '\n',
    '                 min = dist[v]',
    '\n',
    '                 min_index = v',
    '\n\n',
    '         return min_index',
    '\n\n',
    '     def dijkstra(self, src):',
    '\n\n',
    '         dist = [sys.maxint] * self.V',
    '\n',
    '         dist[src] = 0',
    '\n',
    '         sptSet = [False] * self.V',
    '\n\n',
    '         for cout in range(self.V):',
    '\n\n',
    '             u = self.minDistance(dist, sptSet)',
    '\n\n',
    '             sptSet[u] = True',
    '\n\n',
    '             for v in range(self.V):',
    '\n',
    '                 if self.graph[u][v] > 0 and sptSet[v] == False and \\',
    '\n',
    '                     dist[v] > dist[u] + self.graph[u][v]:',
    '\n',
    '                     dist[v] = dist[u] + self.graph[u][v]',
    '\n\n',
    '         self.printSolution(dist)',
    '\n\n',
    ' g = Graph(9)',
    '\n',
    ' g.graph = [[0, 4, 0, 0, 0, 0, 0, 8, 0],',
    '\n',
    '            [4, 0, 8, 0, 0, 0, 0, 11, 0],',
    '\n',
    '            [0, 8, 0, 7, 0, 4, 0, 0, 2],',
    '\n',
    '            [0, 0, 7, 0, 9, 14, 0, 0, 0],',
    '\n',
    '            [0, 0, 0, 9, 0, 10, 0, 0, 0],',
    '\n',
    '            [0, 0, 4, 14, 10, 0, 2, 0, 0],',
    '\n',
    '            [0, 0, 0, 0, 0, 2, 0, 1, 6],',
    '\n',
    '            [8, 11, 0, 0, 0, 0, 1, 0, 7],',
    '\n',
    '            [0, 0, 2, 0, 0, 0, 6, 7, 0]]',
    '\n',
    ' g.dijkstra(0)',
    '\n\n',
    '#  [GAURAV KUMAR] [so/q/57944460] [cc by-sa 3.0]',
    '\n\n$\n']]